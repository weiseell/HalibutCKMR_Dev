# looping over all the "equals" at the start
# This does the plus-group wrong. We will fix immediately afterwards...
Pr_POP_SYLAB <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, a1=A,
b2=POPY, {
#sd that parent length is currently from the mean
l1 <- Lvec[lc1]
sd1 <- (l1 - la_means_SA[s1,a1])/la_sd_SA[s1,a1]
#age of parent when off is born
a1_at_B2 <- a1 - (y1 - b2)
#length of parent when offspring is born
l1_at_B2 <- la_means_SA[s1,a1_at_B2 |> clamp( A)] +
sd1 * la_sd_SA[s1,a1_at_B2 |> clamp( A)]
l1_at_B2 <- ifelse( l1_at_B2<0, 0, l1_at_B2) # avoid min, max, etc; diffable (?)
# ... preferable to do ifelse() *before* make_fecundity(), so we avoid neg nums to pwr...
#!# switch fecundity input from age-based to length-based in the fecundity
Prob <-
(y1 >= b2) * # otherwise Molly was dead before Dolly born
(a1_at_B2 >= 2) *
make_fecundity(s1,l1_at_B2) * recip_TRO_SY[s1,b2]
Prob
})
# PLUS GROUP FIXUP HERE
# adjusting probabilities to account for plus group
# age of parent is 30+ instead of only 30
#Pr_POP_SYLAB_plus <- autoloop(s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES,
#                              b2=POPY, SUMOVER=list(q=1:numq), {
#sd that parent length is currently from the mean
# calculate what a1 is based on the length
#a1 <- qexp(q/(numq + 1)) * (Abar_plus[s1,y1] - max(A)) + max(A)
#l1 <- Lvec[lc1]
#!# CAN FIX THIS IN THE FUTURE BY CHANGING THE MEANS/SD FOR LENGTH/AGE
# TO A FUNCTION BASED ON LA DATA
#sd1 <- (l1 - la_means_SA[s1,a1])/la_sd_SA[s1,a1]
#age of parent when off is born
#a1_at_B2 <- a1 - (y1 - b2)
#length of parent when offspring is born
#l1_at_B2 <- la_means_SA[s1,a1_at_B2 |> clamp( A)] +
#    sd1 * la_sd_SA[s1,a1_at_B2 |> clamp( A)]
#Prob <- ifelse(l1_at_B2 > 0,
#!# switch fecundity input from age-based to length-based in the fecundity
#  (y1 >= b2) * # otherwise Molly was dead before Dolly born
#  (a1_at_B2 >= 2) *
#  make_fecundity(s1,l1_at_B2) * inv_TRO_SY[s1,b2],
#  0)
#Prob
#})
#Pr_POP_SYLAB[,,,,max(A)] <- Pr_POP_SYLAB_plus
num_Pr_A_SYL <- autoloop(
a=A, s=SEXES, y=SAMPY, lc=LENGTH_CLASSES,
prob_len_at_age[s,lc,a] * N[s,y,a]
)
#denom_SYL <- sumover(num_Pr_A_SYL,'a')
recip_denom_SYL <- 1 / autoloop(
indices=dimseq( num_Pr_A_SYL)[-1],   # see num_Pr_A_SYL above for actual list
SUMOVER=dimseq( num_Pr_A_SYL)[1],    # just the "a"
num_Pr_A_SYL[a, s, y, lc]
)
Pr_A_SYL <- autoloop(
a=A, s=SEXES, y=SAMPY, lc=LENGTH_CLASSES,
num_Pr_A_SYL[a, s, y, lc] * recip_denom_SYL[s, y, lc]
)
Pr_POP_SYLB <- autoloop(s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES,b2=POPY,
SUMOVER = list(a1 = A), {
Pr_POP_SYLAB[s1,y1,lc1,a1,b2] * Pr_A_SYL[a1,s1,y1,lc1]
})
Pr_POP_SYLSYL1 <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES,
SUMOVER=list(a1= A, a2= A),
{
b2 <- y2 - a2
(b2 >= POPY[1]) *
Pr_POP_SYLAB[ s1, y1, lc1, a1, b2 |> clamp(POPY)] *
Pr_A_SYL[ a1, s1, y1, lc1] *
Pr_A_SYL[ a2, s2, y2, lc2]
})
Pr_POP_SYLSYL2 <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES, {
Pr_POP_SYLSYL1[s2,y2,lc2,s1,y1,lc1]
}
)
#expected number of POPs given probability and number of comparisons
E_POP_SYLSYL <- n_comps_POP_SYLSYL * (Pr_POP_SYLSYL1 + Pr_POP_SYLSYL2)
#summing all the calculated likelihoods and adding them to the total
nll <- nll - sum(dpois(c(n_POP_SYLSYL),c(E_POP_SYLSYL),log = T),na.rm = T)
####
## likelihoods with Second-Order Kin Pairs ###
## combines grandparent/grandchild and half-sibling probabilities
## Half-sibling with unseen mother
#ideal probabilities: BB
Pr_HSP_Mat_BB <- autoloop(
b1=POPY,b2=POPY, SUMOVER = list(app=A,qq=(1:nquant)),{
#specify that B2 was born after B1
(b2 >= b1) *
## prob that pp was father of B1
fec_sa_quant[female,app,qq] * recip_TRO_SY[female,b1] *
## prob of parent surviving from B1 to B2
#!# turned this off cause superN is still broken
Pr_Surv_SYAY[female,b1,app,b2] *
N[male,b2,(app + (b2-b1)) |> clamp(A)]/N[male,b1,app] *
## prob that pp was the father of B2
fec_sa_quant[female,(app + (b2-b1)) |> clamp(A),qq] * recip_TRO_SY[female,b2] *
## lucky litter factor - same cohort HS problem
ifelse(b2==b1,
lucky_litter_par,1)
}
)
#blur into SYLSYL
Pr_HSP_Mat_SYLSYL <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES,
SUMOVER=list(b1=POPY,b2= POPY),{
# calculate ages based on sample and birth year
a1 <- y1 - b1
a2 <- y2 - b2
# blur the BB probabilities into SYLSYL
Pr_HSP_Mat_BB[b1,b2] *
Pr_A_SYL[a1 |> clamp(A), s1, y1, lc1] *
Pr_A_SYL[a2 |> clamp(A), s2, y2, lc2]
}
)
## Half-sibling with unseen father
#ideal probabilities: BB
Pr_HSP_Pat_BB <- autoloop(
balpha=POPY,bbeta=POPY, SUMOVER = list(app=A,qq=(1:nquant)),{
## specify this so that (hopefully) we fill in both sides of the probability triangle
# need to do that because when we blur over length there's no guarantee that b1 < b2
# so we need the non-zero probability in both directions
b1 <- pmin(balpha, bbeta)
b2 <- pmax(balpha, bbeta)
## prob that pp was father of B1
fec_sa_quant[male,app,qq] * recip_TRO_SY[male,b1] *
## prob of parent surviving from B1 to B2
#!# turned this off because superN is still broken
Pr_Surv_SYAY[male,b1,app,b2] *
N[male,b2,(app + (b2-b1)) |> clamp(A)]/N[male,b1,app] *
## prob that pp was the father of B2
fec_sa_quant[male,(app + (b2-b1)) |> clamp(A),qq] * recip_TRO_SY[male,b2] *
## lucky litter factor - same cohort HS problem
ifelse(b2==b1,
lucky_litter_par,1)
}
)
#blur into SYLSYL
Pr_HSP_Pat_SYLSYL <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES,
SUMOVER=list(b1=POPY,b2= POPY),{
# calculate ages based on sample and birth year
a1 <- y1 - b1
a2 <- y2 - b2
# blur the BB probabilities into SYLSYL
Pr_HSP_Pat_BB[b1,b2] *
Pr_A_SYL[a1 |> clamp(A), s1, y1, lc1] *
Pr_A_SYL[a2 |> clamp(A), s2, y2, lc2]
}
)
## Grandparent-Grandchild with unseen mother
#idealized probability calculation
Pr_GPP_Mat_SYLB <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, b2=POPY,
SUMOVER=list(app=A), {
## two prob comp
bpp <- b2 - app
(bpp <= PopYear1) *
# prob that app is age A given b2
fec_sa[female,app] * recip_TRO_SY[female,b2] *
# POP prob for GP to be app's parent
Pr_POP_SYLB[s1,y1,lc1,bpp |> clamp(POPY)]
}
)
# blurring probability to sum over potential ages based on length
Pr_GPP_Mat_SYLSYL1 <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES,
SUMOVER=list(a2 = A),
{
#calculating gk birth year
b2 <- y2 - a2
(b2 >= PopYear1) *
Pr_GPP_Mat_SYLB[s1, y1, lc1, b2 |> clamp(POPY)] *
Pr_A_SYL[a2, s2, y2, lc2]
})
Pr_GPP_Mat_SYLSYL2 <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES, {
Pr_GPP_Mat_SYLSYL1[s2,y2,lc2,s1,y1,lc1]
}
)
## Grandparent-Grandchild with unseen father
#idealized probability calculation
Pr_GPP_Pat_SYLB <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, b2=POPY,
SUMOVER=list(app=A), {
## two prob comp
bpp <- b2 - app
(bpp <= PopYear1) *
# prob that app is age A given b2
fec_sa[male,app] * recip_TRO_SY[male,b2] *
# POP prob for GP to be app's parent
Pr_POP_SYLB[s1,y1,lc1,bpp |> clamp(POPY)]
}
)
# blurring probability to sum over potential ages based on length
Pr_GPP_Pat_SYLSYL1 <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES,
SUMOVER=list(a2= A),
{
#calculating gk birth year
b2 <- y2 - a2
(b2 >= PopYear1) *
Pr_GPP_Pat_SYLB[s1, y1, lc1, b2 |> clamp(POPY)] *
Pr_A_SYL[a2, s2, y2, lc2]
})
#for weird case where the grandparent was indiv 2
Pr_GPP_Pat_SYLSYL2 <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, s2=SEXES, y2=SAMPY, lc2=LENGTH_CLASSES, {
Pr_GPP_Pat_SYLSYL1[s2,y2,lc2,s1,y1,lc1]
}
)
## combining half-sib and GPP probs
Pr_TKP_SYLSYL <- Pr_HSP_Mat_SYLSYL + Pr_HSP_Pat_SYLSYL +
Pr_GPP_Mat_SYLSYL1 + Pr_GPP_Mat_SYLSYL2 +
Pr_GPP_Pat_SYLSYL1 + Pr_GPP_Pat_SYLSYL2
## generating exp kin pairs
E_N_TKP_SYLSYL <- n_comps_POP_SYLSYL* Pr_TKP_SYLSYL
## summing likelihoods for all cases
nll <- nll - sum(dpois(c(N_TKP_SYLSYL),c(E_N_TKP_SYLSYL),log = T),na.rm = T)
#!# Add mitoDNA HERE
for (i in 1:nrow(TKPairs)) {
#grabbing values fron the mtDNA data input
TKP_s1 <- TKPairs$s1[i]
TKP_y1 <- TKPairs$y1[i]
TKP_l1 <- TKPairs$l1[i]
TKP_s2 <- TKPairs$s2[i]
TKP_y2 <- TKPairs$y2[i]
TKP_l2 <- TKPairs$l2[i]
TKP_h1 <- TKPairs$h1[i]
TKP_h2 <- TKPairs$h2[i]
## conditionalish probabilities for all four cases
#HSP maternal - if they match it's 1, no match 0
Pr_h2_h1_HSP_Mat <- ifelse(TKP_h1==TKP_h2,1,0)
#HSP paternal - prob of match is just the haplotype frequency
Pr_h2_h1_HSP_Pat <- HapFreq[TKP_h2]
#GPP maternal - nested ifelse where sex of grandparent is male/female
#for maternal grandmother, it is the 1/0 prob like mat HS
# for maternal grandfather, is the hap frequency
Pr_h2_h1_GPP_Mat1 <- ifelse(TKP_s1==female,ifelse(TKP_h1==TKP_h2,1,0),HapFreq[TKP_h2])
# case where bc of weird length stuff indiv 2 is the maternal grandparent instead of grandchild
Pr_h2_h1_GPP_Mat2 <- ifelse(TKP_s2==female,ifelse(TKP_h2==TKP_h1,1,0),HapFreq[TKP_h2])
#GPP paternal - heritance is broken so whatevs
Pr_h2_h1_GPP_Pat1 <- HapFreq[TKP_h2]
Pr_h2_h1_GPP_Pat2 <- HapFreq[TKP_h2]
## stitch together 6 cases into the overall probability of h1 and h2 to be added to the likelihood
Pr_h2_h1_TKP_SYLSYL <-
# prob of mat HSP for SYLSYL pair i multiplied by the haplotype probability
Pr_HSP_Mat_SYLSYL[TKP_s1,TKP_y1,TKP_l1,TKP_s2,TKP_y2,TKP_l2] * Pr_h2_h1_HSP_Mat +
# prob of pat HSP for SYLSYL pair i multiplied by the haplotype probability
Pr_HSP_Pat_SYLSYL[TKP_s1,TKP_y1,TKP_l1,TKP_s2,TKP_y2,TKP_l2] * Pr_h2_h1_HSP_Pat +
# prob of mat GPP for SYLSYL pair i multiplied by the haplotype probability
Pr_GPP_Mat_SYLSYL1[TKP_s1,TKP_y1,TKP_l1,TKP_s2,TKP_y2,TKP_l2] * Pr_h2_h1_GPP_Mat1 +
# prob of mat GPP for SYLSYL pair i multiplied by the haplotype probability
# for the problem case when grandchild is indiv 1
Pr_GPP_Mat_SYLSYL2[TKP_s1,TKP_y1,TKP_l1,TKP_s2,TKP_y2,TKP_l2] * Pr_h2_h1_GPP_Mat2 +
# prob of pat GPP for SYLSYL pair i multiplied by the haplotype probability
Pr_GPP_Pat_SYLSYL1[TKP_s1,TKP_y1,TKP_l1,TKP_s2,TKP_y2,TKP_l2] * Pr_h2_h1_GPP_Pat1 +
# prob of pat GPP for SYLSYL pair i multiplied by the haplotype probability
# for the problem case when grandchild is indiv 1
Pr_GPP_Pat_SYLSYL2[TKP_s1,TKP_y1,TKP_l1,TKP_s2,TKP_y2,TKP_l2] * Pr_h2_h1_GPP_Pat2
#divide probability the same denominator - Pr_TKP_SYLSYL because we've established that they are
#SOKPs before we started the loop
full_hap_Pr <- Pr_h2_h1_TKP_SYLSYL/Pr_TKP_SYLSYL[TKP_s1,TKP_y1,TKP_l1,TKP_s2,TKP_y2,TKP_l2]
#add prob to the likelihood
nll <- -log(full_hap_Pr)
}
## Age composition data
#samp_asyl is an input created for the data
#adds to the likelihood probabilities based on the age composition
#list of ages identified for each length bin in a given sample year
#only use when we have across-sample age data, which we don't have much of rn
#nll <- nll - sum(log(Pr_A_SYL[MATSUB=samp_asyl]))
REPORTO(N, Z, E_POP_SYLSYL, E_N_TKP_SYLSYL, fec_sa)
##Return nll
nll
})
tmbmap = list(log_rec=as.factor(rep(NA,length(parm$log_rec))))
testo = MakeADFun(new_f,parm,random=c("log_rec"),map = tmbmap)
testo$gr()
?pgamma
### Fecundity function fix
#defining shape and scale parameters for pgamma in the
#fecundity things
dat <- within( dat, {
la_shape_SA <- (la_means_SA/la_sd_SA)^2
la_scale_SA <- la_means_SA/la_shape_SA
})
getAll(dat,parm)
fec_sa_quant <- autoloop(
s=SEXES, a=A, qq=(1:nquant), {
#calculating length for quantile at mean/sd
#l_q <- qnorm(qq/(nquant + 1),mean = la_means_SA[s,a],sd = la_sd_SA[s,a])
l_q <- qgamma(qq/(nquant + 1),
shape = la_shape_SA[s,a],
scale = la_scale_SA[s,a])
#make fecundity for length given prob
make_fecundity(s,l_q) * (1/nquant)
})
fec_sa_quant
fec_sa_quant[SLICE=2,,]
la_shape_SA
la_scale_SA
a <- 3
s <- 2
#calculating length for quantile at mean/sd
#l_q <- qnorm(qq/(nquant + 1),mean = la_means_SA[s,a],sd = la_sd_SA[s,a])
l_q <- qgamma(qq/(nquant + 1),
shape = la_shape_SA[s,a],
scale = la_scale_SA[s,a])
mean(rgamma(10000,
shape = la_shape_SA[s,a],
scale = la_scale_SA[s,a]))
fec_sa_quant <- autoloop(
s=SEXES, a=A, qq=(1:nquant), {
#calculating length for quantile at mean/sd
#l_q <- qnorm(qq/(nquant + 1),mean = la_means_SA[s,a],sd = la_sd_SA[s,a])
l_q <- qgamma(qq/(nquant + 1),
shape = la_shape_SA[s,a],
scale = la_scale_SA[s,a])
#make fecundity for length given prob
make_fecundity(s,l_q) * (1/nquant)
})
qq1 <- pgamma(l1,shape = la_shape_SA[s1,a1],scale = la_scale_SA[s1,a1])
l1 <- 40
s1 <- 2
a1 <- 5
qq1 <- pgamma(l1,shape = la_shape_SA[s1,a1],scale = la_scale_SA[s1,a1])
qq1
l1 <- 70
qq1 <- pgamma(l1,shape = la_shape_SA[s1,a1],scale = la_scale_SA[s1,a1])
qq1
#length of parent when offspring is born
l1_at_B2 <- qgamma(qq1,shape = la_shape_SA[s1,a1_at_B2],
scale = la_scale_SA[s1,a1_at_B2])
y1 <- 11
b2 <- 2
#age of parent when off is born
a1_at_B2 <- a1 - (y1 - b2)
#length of parent when offspring is born
l1_at_B2 <- qgamma(qq1,shape = la_shape_SA[s1,a1_at_B2],
scale = la_scale_SA[s1,a1_at_B2])
a1
a1_at_B2 <- 35
#length of parent when offspring is born
l1_at_B2 <- qgamma(qq1,shape = la_shape_SA[s1,a1_at_B2],
scale = la_scale_SA[s1,a1_at_B2])
a1_at_B2 <- 25
#length of parent when offspring is born
l1_at_B2 <- qgamma(qq1,shape = la_shape_SA[s1,a1_at_B2],
scale = la_scale_SA[s1,a1_at_B2])
l1_at_B2
## POP nll using CKMR data ###
# generating the POP probabilities
# This does all ages for IDEAL measurement
# autoloop() both CREATES the array and FILLS IT IN
# looping over all the "equals" at the start
# This does the plus-group wrong. We will fix immediately afterwards...
Pr_POP_SYLAB <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, a1=A,
b2=POPY, {
#sd that parent length is currently from the mean
l1 <- Lvec[lc1]
#sd1 <- (l1 - la_means_SA[s1,a1])/la_sd_SA[s1,a1]
qq1 <- pgamma(l1,shape = la_shape_SA[s1,a1],scale = la_scale_SA[s1,a1])
#age of parent when off is born
a1_at_B2 <- a1 - (y1 - b2)
#length of parent when offspring is born
l1_at_B2 <- qgamma(qq1,shape = la_shape_SA[s1,a1_at_B2 |> clamp(A)],
scale = la_scale_SA[s1,a1_at_B2] |> clamp(A))
#l1_at_B2 <- la_means_SA[s1,a1_at_B2 |> clamp( A)] +
#  sd1 * la_sd_SA[s1,a1_at_B2 |> clamp( A)]
#l1_at_B2 <- ifelse( l1_at_B2<0, 0, l1_at_B2) # avoid min, max, etc; diffable (?)
# ... preferable to do ifelse() *before* make_fecundity(), so we avoid neg nums to pwr...
#!# switch fecundity input from age-based to length-based in the fecundity
Prob <-
(y1 >= b2) * # otherwise Molly was dead before Dolly born
(a1_at_B2 >= 2) *
make_fecundity(s1,l1_at_B2) * recip_TRO_SY[s1,b2]
Prob
})
#length of parent when offspring is born
l1_at_B2 <- qgamma(qq1,shape = la_shape_SA[s1,a1_at_B2 |> clamp(A)],
scale = la_scale_SA[s1,a1_at_B2 |> clamp(A)])
## POP nll using CKMR data ###
# generating the POP probabilities
# This does all ages for IDEAL measurement
# autoloop() both CREATES the array and FILLS IT IN
# looping over all the "equals" at the start
# This does the plus-group wrong. We will fix immediately afterwards...
Pr_POP_SYLAB <- autoloop(
s1=SEXES, y1=SAMPY, lc1=LENGTH_CLASSES, a1=A,
b2=POPY, {
#sd that parent length is currently from the mean
l1 <- Lvec[lc1]
#sd1 <- (l1 - la_means_SA[s1,a1])/la_sd_SA[s1,a1]
qq1 <- pgamma(l1,shape = la_shape_SA[s1,a1],scale = la_scale_SA[s1,a1])
#age of parent when off is born
a1_at_B2 <- a1 - (y1 - b2)
#length of parent when offspring is born
l1_at_B2 <- qgamma(qq1,shape = la_shape_SA[s1,a1_at_B2 |> clamp(A)],
scale = la_scale_SA[s1,a1_at_B2 |> clamp(A)])
#l1_at_B2 <- la_means_SA[s1,a1_at_B2 |> clamp( A)] +
#  sd1 * la_sd_SA[s1,a1_at_B2 |> clamp( A)]
#l1_at_B2 <- ifelse( l1_at_B2<0, 0, l1_at_B2) # avoid min, max, etc; diffable (?)
# ... preferable to do ifelse() *before* make_fecundity(), so we avoid neg nums to pwr...
#!# switch fecundity input from age-based to length-based in the fecundity
Prob <-
(y1 >= b2) * # otherwise Molly was dead before Dolly born
(a1_at_B2 >= 2) *
make_fecundity(s1,l1_at_B2) * recip_TRO_SY[s1,b2]
Prob
})
nll <- sum(dnorm(diff(log_rec), mean=0, sd=log_rec_sd))
log_rec_sd
log_rec
iff(log_rec)
diff(log_rec)
nll <- sum(dnorm(diff(log_rec), mean=0, sd=log_rec_sd))
dnorm(diff(log_rec), mean=0, sd=log_rec_sd)
log_rec_sd
dnorm(diff(log_rec), mean=0, sd=log_rec_sd)
log_rec
nll <- sum(dnorm(diff(log_rec), mean=0, sd=rec_sd))
#log recruitment - random effect length popdynyears
parm$rw_log_rec <- log(Narray[1,,1] + Narray[1,,2])
parm$rw_log_rec_sd = log(0.3)
rw_log_rec <- log(Narray[1,,1] + Narray[1,,2])
rw_log_rec_sd = log(0.3)
parm$noise_logrec_dev <- Narray[1,,1] * 0
parm$noise_logrec_dev
parm$noise_rec_dev_sd = log(0.3)
parm$noise_rec_dev_sd_log = log(0.3)
#log recruitment - random effect length popdynyears
parm$rw_log_rec <- log(Narray[1,,1] + Narray[1,,2])
parm$rw_log_rec_sd = log(0.3)
parm$noise_logrec_dev <- Narray[1,,1] * 0
parm$noise_rec_dev_sd_log = log(0.3)
noise_rec_dev_sd <- exp(noise_rec_dev_sd_log)
lucky_litter_par <- exp(log_lucky_litter_par)
getAll(dat,parm)
noise_rec_dev_sd <- exp(noise_rec_dev_sd_log)
lucky_litter_par <- exp(log_lucky_litter_par)
nll <- sum(dnorm(noise_logrec_dev, mean=0, sd=noise_rec_dev_sd))
cumul_rw_logrec <- cumsum(rw_log_rec)
cumul_rw_logrec + noise_logrec_dev
exp(cumul_rw_logrec + noise_logrec_dev)
cumul_rw_logrec
rw_log_rec
#log recruitment - random effect length popdynyears
parm$rw_log_rec <- Narray[1,,1] * 0
parm$rw_log_rec_sd = log(0.3)
parm$noise_logrec_dev <- Narray[1,,1] * 0
parm$noise_rec_dev_sd_log = log(0.3)
getAll(dat,parm)
nll <- sum(dnorm(diff(rw_log_rec), mean=0, sd=rw_rec_sd))
nll <- sum(dnorm(noise_logrec_dev, mean=0, sd=noise_rec_dev_sd))
rw_log_rec
nll <- sum(dnorm(diff(rw_log_rec), mean=0, sd=rw_rec_sd))
rw_rec_sd
#exp the sd
rw_rec_sd = exp(rw_log_rec_sd)
nll <- sum(dnorm(diff(rw_log_rec), mean=0, sd=rw_rec_sd))
nll <- sum(dnorm(noise_logrec_dev, mean=0, sd=noise_rec_dev_sd))
cumul_rw_logrec <- cumsum(rw_log_rec)
noise_logrec_dev
noise_rec_dev_sd
nll <- sum(dnorm(noise_logrec_dev, mean=0, sd=noise_rec_dev_sd_log))
noise_rec_dev_sd <- exp(noise_rec_dev_sd_log)
nll <- sum(dnorm(noise_logrec_dev, mean=0, sd=noise_rec_dev_sd))
cumul_rw_logrec <- cumsum(rw_log_rec)
rec <- exp(cumul_rw_logrec + noise_logrec_dev)
rec
#per year change in recruitment
rec_mul <- exp(cumul_rw_logrec + noise_logrec_dev)
parm$rec <- log(c(0,0))
parm$rec
rec <- exp(log_rec)
parm$log_rec <- c(0,0)
parm$log_rec <- c(10,10)
rec <- exp(log_rec)
#per year change in recruitment
rec_mul <- exp(cumul_rw_logrec + noise_logrec_dev)
##Put in recruitment
for(s in 1:2){
N[s,,2] = rec[s] * rec_mul
}
rec[s]
parm$log_init_abundance <- log(sum(Narray[-1,1,]))
log(sum(Narray[-1,1,]))
log(sum(Narray[-1,1,]))
sum(Narray[-1,1,])
parm$logslopea0 <- log(0.2)
parm$ppn_female <- 0.5
getAll(dat,parm)
## calculating the first year for all ages
Ny0 <- offarray(0, dimseq = list(AGE=A))
Ny0[min(A)] <- 1
slopea0 <- exp(-logslopea0)
for (a in (min(A)+1):max(A)) {
Ny0[a] <- Ny0[a-1] * slopea0
}
Ny0
slopea0
Ny0[max(A)] <- Ny0[max(A)]/(1-slopea0)
log_init_abundance <- log(sum(Narray[-1,1,]))
N[female,min(POPY),] <- Ny0 * ppn_female
N[male,min(POPY),] <- Ny0 * (1-ppn_female)
